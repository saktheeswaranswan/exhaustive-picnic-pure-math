# -*- coding: utf-8 -*-
"""exhastive-purematrh.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uI720fV1zsspZO2e3lMsRTCiv-8e9vCY
"""

import numpy as np
from itertools import combinations

def calculate_vieta_relationships(coefficients):
    # Find the roots
    roots = np.roots(coefficients)

    # Calculate n (degree of the polynomial)
    n = len(coefficients) - 1

    # Calculate Vieta's relationships
    sum_of_roots = sum(roots)
    sum_of_products_2 = sum(np.prod(comb) for comb in combinations(roots, 2))
    product_of_roots = np.prod(roots)

    # Coefficients
    a_n = coefficients[0]
    a_n_minus_1 = coefficients[1]
    a_n_minus_2 = coefficients[2] if n > 1 else 0
    a_0 = coefficients[-1]

    # Verify Vieta's formulas
    vieta_sum = -a_n_minus_1 / a_n
    vieta_sum_2 = a_n_minus_2 / a_n
    vieta_product = (-1)**n * a_0 / a_n

    # Print results
    print("Calculated Values:")
    print(f"Sum of Roots: {sum_of_roots} (Expected: {vieta_sum})")
    print(f"Sum of Products of Roots (2 at a time): {sum_of_products_2} (Expected: {vieta_sum_2})")
    print(f"Product of Roots: {product_of_roots} (Expected: {vieta_product})")

def main():
    # Example polynomial coefficients for x^6 - 5x^5 + 10x^4 - 10x^3 + 5x^2 - 1
    coefficients = [1, -5, 10, -10, 5, 0, -1]  # Change as needed

    calculate_vieta_relationships(coefficients)

if __name__ == "__main__":
    main()

import numpy as np
import sympy as sp
from itertools import combinations

def find_numeric_roots(coefficients):
    # Find roots numerically using numpy
    roots = np.roots(coefficients)
    return roots

def verify_vieta_symbolically(degree):
    # Define a symbolic polynomial
    a = sp.symbols('a0 a1 a2 a3 a4 a5 a6')
    coeffs = [a[degree]] + [a[i] for i in range(degree)]  # Coefficients a_n, a_(n-1), ..., a_0
    x = sp.symbols('x')
    polynomial = sum(c * x**(degree - i) for i, c in enumerate(coeffs))

    # Derive Vieta's formulas symbolically
    roots = sp.solve(polynomial, x)
    sum_of_roots = sp.Add(*roots)
    sum_of_products_2 = sum(sp.prod(comb) for comb in combinations(roots, 2))
    product_of_roots = sp.prod(roots)

    return sum_of_roots, sum_of_products_2, product_of_roots

def check_combinations(roots):
    sum_of_roots = sum(roots)
    sum_of_products_2 = sum(np.prod(comb) for comb in combinations(roots, 2))
    product_of_roots = np.prod(roots)

    return sum_of_roots, sum_of_products_2, product_of_roots

def main():
    # Coefficients for a polynomial of degree 6: x^6 - 5x^5 + 10x^4 - 10x^3 + 5x^2 - 1
    coefficients = [1, -5, 10, -10, 5, 0, -1]

    # Step 1: Find roots numerically
    roots = find_numeric_roots(coefficients)
    print("Numerical Roots:", roots)

    # Step 2: Symbolic verification of Vieta's relationships
    degree = len(coefficients) - 1
    sum_of_roots_sym, sum_of_products_2_sym, product_of_roots_sym = verify_vieta_symbolically(degree)
    print("Symbolic Vieta's Sums:")
    print("Sum of Roots (Symbolic):", sum_of_roots_sym)
    print("Sum of Products of Roots (2 at a time, Symbolic):", sum_of_products_2_sym)
    print("Product of Roots (Symbolic):", product_of_roots_sym)

    # Step 3: Check combinations
    sum_of_roots, sum_of_products_2, product_of_roots = check_combinations(roots)
    print("\nChecked Combinations:")
    print("Sum of Roots (Numerical):", sum_of_roots)
    print("Sum of Products of Roots (2 at a time, Numerical):", sum_of_products_2)
    print("Product of Roots (Numerical):", product_of_roots)

if __name__ == "__main__":
    main()

import numpy as np
from itertools import combinations

def find_numeric_roots(coefficients):
    # Find roots numerically using numpy
    roots = np.roots(coefficients)
    return roots

def check_combinations(roots):
    results = {}

    for k in range(1, len(roots) + 1):
        combs = combinations(roots, k)
        results[k] = []
        for comb in combs:
            sum_comb = sum(comb)
            prod_comb = np.prod(comb)
            results[k].append((comb, sum_comb, prod_comb))

    return results

def main():
    # Coefficients for a polynomial of degree 6: x^6 - 5x^5 + 10x^4 - 10x^3 + 5x^2 - 1
    coefficients = [1, -5, 10, -10, 5, 0, -1]

    # Step 1: Find roots numerically
    roots = find_numeric_roots(coefficients)
    print("Numerical Roots:", roots)

    # Step 2: Check combinations
    combination_results = check_combinations(roots)

    # Display combinations and their sums and products
    for k, comb_list in combination_results.items():
        print(f"\nCombinations of size {k}:")
        for comb, sum_comb, prod_comb in comb_list:
            print(f"Combination: {comb}, Sum: {sum_comb}, Product: {prod_comb}")

if __name__ == "__main__":
    main()

import numpy as np
from itertools import combinations

def find_numeric_roots(coefficients):
    # Find roots numerically using numpy
    roots = np.roots(coefficients)
    return roots

def check_combinations(roots):
    results = {}

    for k in range(1, len(roots) + 1):
        combs = combinations(roots, k)
        results[k] = []
        for comb in combs:
            sum_comb = sum(comb)
            prod_comb = np.prod(comb)
            results[k].append((comb, sum_comb, prod_comb))

    return results

def main():
    while True:
        try:
            # User input for the degree of the polynomial
            degree = int(input("Enter the degree of the polynomial (between 2 and 1000, or 0 to exit): "))
            if degree == 0:
                print("Exiting...")
                break
            if degree < 2 or degree > 1000:
                print("Please enter a degree between 2 and 1000.")
                continue

            # Random coefficients: leading coefficient between 1 and 10, others between -10 and 10
            coefficients = [np.random.randint(1, 11)] + np.random.randint(-10, 11, degree)
            print(f"\nPolynomial of Degree {degree}: Coefficients: {coefficients}")

            # Step 1: Find roots numerically
            roots = find_numeric_roots(coefficients)
            print("Numerical Roots:", roots)

            # Step 2: Check combinations
            combination_results = check_combinations(roots)

            # Display combinations and their sums and products
            for k, comb_list in combination_results.items():
                print(f"\nCombinations of size {k}:")
                for comb, sum_comb, prod_comb in comb_list:
                    print(f"Combination: {comb}, Sum: {sum_comb}, Product: {prod_comb}")

        except ValueError:
            print("Invalid input. Please enter a valid integer.")

if __name__ == "__main__":
    main()

import numpy as np
from itertools import combinations

def find_numeric_roots(coefficients):
    # Find roots numerically using numpy
    roots = np.roots(coefficients)
    return roots

def viete_sums_products(roots):
    n = len(roots)
    sums = {}
    products = {}

    for k in range(1, n + 1):
        sums[k] = -np.sum(np.prod(combinations(roots, k), axis=1))
        products[k] = (-1) ** k * np.prod(roots) if k == n else None

    return sums, products

def check_combinations(roots):
    results = {}

    for k in range(1, len(roots) + 1):
        combs = combinations(roots, k)
        results[k] = []
        for comb in combs:
            sum_comb = sum(comb)
            prod_comb = np.prod(comb)
            results[k].append((comb, sum_comb, prod_comb))

    return results

def main():
    while True:
        try:
            # User input for the degree of the polynomial
            degree = int(input("Enter the degree of the polynomial (between 2 and 1000, or 0 to exit): "))
            if degree == 0:
                print("Exiting...")
                break
            if degree < 2 or degree > 1000:
                print("Please enter a degree between 2 and 1000.")
                continue

            # Random coefficients: leading coefficient between 1 and 10, others between -10 and 10
            coefficients = [np.random.randint(1, 11)] + np.random.randint(-10, 11, degree)
            print(f"\nPolynomial of Degree {degree}: Coefficients: {coefficients}")

            # Step 1: Find roots numerically
            roots = find_numeric_roots(coefficients)
            print("Numerical Roots:", roots)

            # Step 2: Apply Vieta's formulas
            viete_sums, viete_products = viete_sums_products(roots)

            print("\nVieta's Sums and Products:")
            for k in range(1, degree + 1):
                print(f"Sum of roots taken {k} at a time: {viete_sums[k]}")
                if k == degree:
                    print(f"Product of all roots: {viete_products[k]}")

            # Step 3: Check combinations
            combination_results = check_combinations(roots)

            # Display combinations and their sums and products
            for k, comb_list in combination_results.items():
                print(f"\nCombinations of size {k}:")
                for comb, sum_comb, prod_comb in comb_list:
                    print(f"Combination: {comb}, Sum: {sum_comb}, Product: {prod_comb}")

        except ValueError:
            print("Invalid input. Please enter a valid integer.")

if __name__ == "__main__":
    main()